#include <sys/types.h>
#include <string.h>
#include <iostream>
#include <arpa/inet.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/time.h>

#include <stdio.h>

#include <map>
#include <string>
#include <netinet/in.h>

#include <thread>
#include <utility>
#include <mutex>
#include "output.h"
#include "messagesBroker.h"

using namespace std;

#define PORT 1504
#define BUFSIZE 1024
#define MAXCLIENTS 50

bool isStop = false;
OutputHandler outputHandler;

class ConnectionManager;

template<>
void MessagesBroker<ConnectionManager>::TerminateTheSubscriberThread(int key);

template<>
void MessagesBroker<ConnectionManager>::TerminateAllSubscribersThreads();

class ExecutableClient
{

   class Command 
   {
   public:
      virtual void Execute(const Message* message){}

      virtual string GetName(){ return "/command"; }
   };

   class Exit : public  Command 
   {
      MessagesBroker<ConnectionManager>* msgsBroker;
      int clientSocket;
   public:
      void Execute(const Message* message) override 
      {
         msgsBroker->IsMessageToSend(new Message(message->GetAuthorSocket(), string("User " + to_string(message->GetAuthorSocket()) + " logged out!")));
         msgsBroker->TerminateTheSubscriberThread(clientSocket);
         msgsBroker->EraseSubscriber(clientSocket);
      }

      string GetName() override
      {
         return "/exit";
      }

      Exit(MessagesBroker<ConnectionManager>* msgsBroker, const int clientSocket)
      {
         this->msgsBroker = msgsBroker;
         this->clientSocket = clientSocket;   
      }
   };

   map<string, Command*> funcMap;
public:

   Executable(MessagesBroker<ConnectionManager>* msgsBroker,const int clientSocket)
   {
      funcMap.insert(make_pair("/exit", new Exit(msgsBroker, clientSocket)));
   }
   
   void ExecuteCommand(string inputStr)
   {
      string commandName = inputStr.substr(0, inputStr.find(" "));
      funcMap[commandName]->Execute(inputStr);
   }
};

class ClientsCommandsHandler
{
public:
   void AnalyzeCommand(const Message* command,  MessagesBroker<ConnectionManager>* msgsBroker, const int clientSocket)
   {  
      string commandStr = command->GetMessage();
      string commandName = commandStr.substr(0, commandStr.find(" "));  
   }
};

class ServerCommandsHandler
{
public:
   void AnalyzeCommand(const string command, MessagesBroker<ConnectionManager>* msgsBroker)
   {   
      string commandName = command.substr(0, command.find(" "));  
      if(commandName == "/stop")
      {       
         isStop = true;
      }
   }
};

class IncomingMessagesHandler
{
   ClientsCommandsHandler handler;

   bool IsItCommand(string commandName)
   {
      return commandName[0] == '/'; 
   }

public:
   void ReciveIncomingMessage(const Message* message, MessagesBroker<ConnectionManager>* msgsBroker, const int clientSocket)
   {
      if (IsItCommand(message->GetMessage()))
      {
         handler.AnalyzeCommand(message, msgsBroker, clientSocket);           
      } else {
         outputHandler.PrintClientMessage(message->GetMessage(), message->GetAuthorSocket());
         msgsBroker->IsMessageToSend(message);
      }        
   }
};

class ConnectionManager
{
   int clientSocket;
   IncomingMessagesHandler incMsgsHandler;
   MessagesBroker<ConnectionManager>* msgsBroker;
   bool isExit = false;
   thread manager;
   
   void Client()
   {
      char buffer[BUFSIZE];

      while(!isExit) 
      {    
         int lastIndex = recv(clientSocket, (char*)buffer, BUFSIZE, 0);
         if (lastIndex != -1)
         {
            buffer[lastIndex] = '\0';
            incMsgsHandler.ReciveIncomingMessage(new Message(clientSocket, string(buffer)), msgsBroker, clientSocket);          
         }
         this_thread::sleep_for(chrono::milliseconds(10));
      }
      cout << "Socket: " << clientSocket << "\n";
      outputHandler.PrintClientMessage(string("User " + to_string(clientSocket) + " logged out!"), clientSocket);        
      close(clientSocket);
   }

public:   
   ConnectionManager(const int socketNum, MessagesBroker<ConnectionManager>* msgsBroker)
   {
      this->clientSocket = socketNum;
      this->msgsBroker = msgsBroker;
      manager = thread(&ConnectionManager::Client, this);
      manager.detach();
   }

   void SendMessage(const Message& msg)
   {
      if (clientSocket != msg.GetAuthorSocket())
      {
         send(clientSocket, msg.GetMessage().c_str(), msg.GetMessage().size(), 0);
      }
   }

   void SendMessageOnlyToThisClient(const Message& msg)
   {
      send(clientSocket, msg.GetMessage().c_str(), msg.GetMessage().size(), 0);
   }
   
   void ChangeExitFlag(bool value)
   {
      isExit = value;
   }
};


template<>
void MessagesBroker<ConnectionManager>::TerminateTheSubscriberThread(int key)
{
   subscribersMap[key]->ChangeExitFlag(true);
}

template<>
void MessagesBroker<ConnectionManager>::TerminateAllSubscribersThreads()
{
      for(auto& element: subscribersMap)
      {
         element.second->SendMessage(*(new Message(-1, "!stop"))); //TODO Заменить магическое число -1
         element.second->ChangeExitFlag(true);
      }
}

class ClientsConnectionsHandler 
{

   int  server, newSocket;  

   struct sockaddr_in serverAddr;
   struct sockaddr_storage serverStorage;
   
   MessagesBroker<ConnectionManager>* msgsBroker;
   thread handler;

   int InitServer()
   { 
      server = socket(AF_INET, SOCK_STREAM, 0);

      if (server < 0)
      {
         cout << "\nError establishing socket...\n";
         exit(EXIT_FAILURE);
      }

      serverAddr.sin_family = AF_INET;
      serverAddr.sin_addr.s_addr = INADDR_ANY;
      serverAddr.sin_port = htons(PORT);

      const int optval = 1;
      setsockopt(server, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(int));
      
      struct timeval rcvTime;
      rcvTime.tv_sec = 0;
      rcvTime.tv_usec = 10000;
      setsockopt(server, SOL_SOCKET, SO_RCVTIMEO, &rcvTime, sizeof(rcvTime));
     
      if ((bind(server, (struct sockaddr*)&serverAddr, sizeof(serverAddr))) < 0)
      {
         cout << "Error binding connection, the socket has already been established...\n";  
         isStop = true;
         return -1;
      }
      if (listen(server, MAXCLIENTS) == 0)
         cout << "Listening\n";
      else
         cout << "Error\n";
   }
  
   void HandlerRoutine() 
   {
      
      while (!isStop)
      {
         socklen_t addr_size = sizeof(serverStorage);
         //TODO: Решить как завершить прослушку подключений клиента при остановке сервера
         newSocket = accept(server, (struct sockaddr*)&serverStorage, &addr_size);
         if (newSocket != -1) 
         {
            ConnectionManager* manager = new ConnectionManager(newSocket, msgsBroker);
            msgsBroker->AddSubscriber(newSocket, manager);                
         }
         this_thread::sleep_for(chrono::milliseconds(10));
      }
   }
public:
   ClientsConnectionsHandler(MessagesBroker<ConnectionManager>* msgsBroker)
   {
      InitServer();
      this->msgsBroker = msgsBroker;
      handler = thread(&ClientsConnectionsHandler::HandlerRoutine, this);
   }

   void JoinRoutineThread()
   {
      handler.join();
   }

   ~ClientsConnectionsHandler()
   {
      close(server);
   }
};


class InputHandler
{
   MessagesBroker<ConnectionManager>* msgsBroker;
   bool IsItCommand(string str)
   {
      return str[0] == '/';
   }   

public:
   InputHandler(MessagesBroker<ConnectionManager>* msgsBroker)
   {
      this->msgsBroker = msgsBroker;
   }

   void ListenInput() 
   {
      string input;
      while(!isStop) 
      {
         getline(cin, input);
         if (IsItCommand(input))
         {
            ServerCommandsHandler handler;
            handler.AnalyzeCommand(input, msgsBroker);
         } else {
            outputHandler.PrintServerMessage("Unknown input!");   
         }
      }
   }
};

int main ()
{
   MessagesBroker<ConnectionManager>* msgsBroker = new MessagesBroker<ConnectionManager>(&isStop);
   ClientsConnectionsHandler* clientsConnectsHandler = new ClientsConnectionsHandler(msgsBroker);
   InputHandler* inputHandler = new InputHandler(msgsBroker);
   
   inputHandler->ListenInput();

   msgsBroker->JoinRoutineThread();
   clientsConnectsHandler->JoinRoutineThread();
   
   delete msgsBroker;
   delete clientsConnectsHandler;
   delete inputHandler;
   return 0;
}  
